% ===============================================================================
% xTEE ESS - DMA HANDOVER WINDOW REPLAY ATTACK MODEL
% ===============================================================================
% 
% THREAT MODEL: DMA Handover Window -> Replay attack
% ATTACKER: Privileged Attacker in the NS world
% VULNERABILITY: Unauthorized access during DMA reconfiguration
% 
% ATTACK SCENARIO:
% 1. The privileged attacker in NSW controls the host OS
% 2. During DMA handover between channels, the attacker injects commands
% 3. The attacker can read obsolete EFBs from flash and attempt replay
% 4. Race conditions during DMA reconfigurations allow unauthorized access

sort
    BlockID = struct block0 | block1 | block2 | block3 | invalid_block;
    SecurityDomain = struct secure | nonsecure | attacker_privileged;
    BlockState = struct encrypted_flash | being_validated | in_ess | in_efbc | executing | compromised;
    AccessPattern = struct sequential | looping | random;
    DMAChannel = struct channel1 | channel2;
    DMAState = struct dma_idle | dma_transferring | dma_compromised | dma_handover;
    MemoryRegion = struct flash | ess | efbc | validator;
    DMAProgress = struct progress0 | progress1 | progress2;
    ValidationResult = struct valid | invalid | not_validated | replayed;
    BlockList = List(BlockID);
    AccessCount = Nat;
    AttackState = struct attack_idle | attack_monitoring | attack_injecting | attack_success;

map
    contains: BlockID # BlockList -> Bool;
    remove_block: BlockID # BlockList -> BlockList;
    add_block: BlockID # BlockList -> BlockList;
    list_size: BlockList -> Nat;
    has_dma_conflict: MemoryRegion # MemoryRegion -> Bool;
    next_block: BlockID # AccessPattern -> BlockID;
    allowed_operation: SecurityDomain # MemoryRegion -> Bool;
    is_vulnerable_handover: DMAChannel # DMAChannel -> Bool;

var
    b, b1, b2: BlockID;
    l: BlockList;
    r1, r2: MemoryRegion;
    p: AccessPattern;
    d: SecurityDomain;
    ch1, ch2: DMAChannel;

eqn
    contains(b, []) = false;
    contains(b, b1 |> l) = (b == b1) || contains(b, l);
    
    remove_block(b, []) = [];
    remove_block(b, b1 |> l) = if(b == b1, l, b1 |> remove_block(b, l));
    
    add_block(b, l) = if(list_size(l) < 2 && !contains(b, l), b |> l, l);
    
    list_size([]) = 0;
    list_size(b |> l) = 1 + list_size(l);
    
    has_dma_conflict(ess, ess) = true;
    has_dma_conflict(efbc, efbc) = true;
    has_dma_conflict(ess, efbc) = true;
    has_dma_conflict(efbc, ess) = true;
    has_dma_conflict(r1, r2) = false;
    
    next_block(block0, sequential) = block1;
    next_block(block1, sequential) = block2;
    next_block(block2, sequential) = block3;
    next_block(block3, sequential) = block0;
    
    allowed_operation(secure, r1) = true;
    allowed_operation(nonsecure, flash) = true;
    allowed_operation(nonsecure, ess) = false;
    allowed_operation(nonsecure, efbc) = false;
    allowed_operation(attacker_privileged, flash) = true;
    allowed_operation(attacker_privileged, ess) = true;  
    allowed_operation(attacker_privileged, efbc) = true;
    
    is_vulnerable_handover(channel1, channel2) = true;
    is_vulnerable_handover(channel2, channel1) = true;
    is_vulnerable_handover(ch1, ch1) = false;

act
    execute_instruction: BlockID # SecurityDomain;
    memfault: BlockID;
    ess_load: BlockID;
    efbc_load: BlockID;
    validate_start: BlockID # SecurityDomain;
    validate_complete: BlockID # ValidationResult;
    dma_request: DMAChannel # BlockID # MemoryRegion # MemoryRegion;
    dma_progress: DMAChannel # DMAProgress;
    dma_complete: DMAChannel # BlockID;
    security_violation: SecurityDomain # MemoryRegion;
    
    attacker_monitor_dma: DMAChannel;
    attacker_inject_command: DMAChannel # BlockID;
    attacker_read_obsolete_efb: BlockID;
    attacker_attempt_replay: BlockID # ValidationResult;
    dma_handover_start: DMAChannel # DMAChannel;
    dma_handover_complete: DMAChannel # DMAChannel;
    dma_race_condition_detected;
    attack_successful: BlockID;
    host_os_compromised;
    
    send_validation_request: BlockID # SecurityDomain;
    receive_validation_request: BlockID # SecurityDomain;
    send_validation_result: BlockID # ValidationResult;
    receive_validation_result: BlockID # ValidationResult;
    sync_validation_request: BlockID # SecurityDomain;
    sync_validation_result: BlockID # ValidationResult;

    send_dma_attack_request: DMAChannel # BlockID;
    receive_dma_attack_request: DMAChannel # BlockID;
    send_attack_result: BlockID # ValidationResult;
    receive_attack_result: BlockID # ValidationResult;
    sync_dma_attack_request: DMAChannel # BlockID;
    sync_attack_result: BlockID # ValidationResult;
    
    send_handover_signal: DMAChannel # DMAChannel;
    receive_handover_signal: DMAChannel # DMAChannel;
    sync_handover_signal: DMAChannel # DMAChannel;

proc
    xTEESystemWithAttacker = 
        EnclaveExecutor(block0, [], [], secure, sequential, 0, 0, 0, 0)
        || ESSManager([], not_validated, not_validated, not_validated, not_validated)
        || CompromisedDMAController(dma_idle, invalid_block, progress0, dma_idle, invalid_block, progress0)
        || ValidationEngine(invalid_block, secure)
        || PrivilegedAttacker(attack_idle, [], []);

    PrivilegedAttacker(state: AttackState, monitored_blocks: BlockList, 
                      obsolete_blocks: BlockList) =
        
        (state == attack_idle) ->
            sum ch: DMAChannel . 
                attacker_monitor_dma(ch) .
                PrivilegedAttacker(attack_monitoring, monitored_blocks, obsolete_blocks)
        +
        (state == attack_monitoring) ->
            sum b: BlockID . 
                attacker_read_obsolete_efb(b) .
                PrivilegedAttacker(attack_monitoring, monitored_blocks, 
                                 add_block(b, obsolete_blocks))
        +
        (state == attack_monitoring && list_size(obsolete_blocks) > 0) ->
            sum ch1, ch2: DMAChannel, b: BlockID . 
                (is_vulnerable_handover(ch1, ch2) && contains(b, obsolete_blocks)) ->
                    dma_race_condition_detected .
                    send_handover_signal(ch1, ch2) .  
                    send_dma_attack_request(ch1, b) . 
                    PrivilegedAttacker(attack_injecting, monitored_blocks, obsolete_blocks)
        +
        (state == attack_injecting) ->
            sum b: BlockID, result: ValidationResult . 
        (contains(b, obsolete_blocks)) ->
            receive_attack_result(b, result) .
            (result == replayed) ->
                attacker_attempt_replay(b, result) .
                attack_successful(b) .
                PrivilegedAttacker(attack_success, monitored_blocks, obsolete_blocks);

    CompromisedDMAController(ch1_state: DMAState, ch1_block: BlockID, ch1_progress: DMAProgress,
                           ch2_state: DMAState, ch2_block: BlockID, ch2_progress: DMAProgress) =
        sum b: BlockID . 
        (ch1_state == dma_idle) ->
            dma_request(channel1, b, ess, efbc) .
            CompromisedDMAController(dma_transferring, b, progress0,
                                   ch2_state, ch2_block, ch2_progress)
    +
    (ch1_state == dma_transferring && ch1_progress == progress0) ->
        dma_progress(channel1, progress1) .
        CompromisedDMAController(dma_transferring, ch1_block, progress1,
                                ch2_state, ch2_block, ch2_progress)
    +
    (ch1_state == dma_transferring && ch1_progress == progress1) ->
        dma_progress(channel1, progress2) .
        CompromisedDMAController(dma_transferring, ch1_block, progress2,
                                ch2_state, ch2_block, ch2_progress)
    +
    (ch1_state == dma_transferring && ch1_progress == progress2) ->
        dma_complete(channel1, ch1_block) .
        efbc_load(ch1_block) .
        CompromisedDMAController(dma_idle, invalid_block, progress0,
                                ch2_state, ch2_block, ch2_progress)
    +
    sum ch_from, ch_to: DMAChannel . 
        receive_handover_signal(ch_from, ch_to) .
        dma_handover_start(ch_from, ch_to) .
        CompromisedDMAController(dma_handover, ch1_block, ch1_progress,
                               dma_handover, ch2_block, ch2_progress)
    +
    sum ch: DMAChannel, b: BlockID . 
        ((ch1_state == dma_handover || ch2_state == dma_handover)) ->
            receive_dma_attack_request(ch, b) .
            attacker_inject_command(ch, b) .
            (
                (ch == channel1) ->
                    send_attack_result(b, replayed) .
                    CompromisedDMAController(dma_compromised, b, progress0,
                                           ch2_state, ch2_block, ch2_progress)
                +
                (ch == channel2) ->
                    send_attack_result(b, replayed) .
                    CompromisedDMAController(ch1_state, ch1_block, ch1_progress,
                                           dma_compromised, b, progress0)
            )
    +
    (ch1_state == dma_handover || ch2_state == dma_handover) ->
        dma_handover_complete(channel1, channel2) .
        CompromisedDMAController(dma_idle, invalid_block, progress0,
                               dma_idle, invalid_block, progress0);

    EnclaveExecutor(current: BlockID, efbc_list: BlockList, ess_list: BlockList, 
                    domain: SecurityDomain, pattern: AccessPattern,
                    cnt0: AccessCount, cnt1: AccessCount, 
                    cnt2: AccessCount, cnt3: AccessCount) =
        
        (contains(current, efbc_list) && domain == secure) ->
            execute_instruction(current, domain) .
            EnclaveExecutor(next_block(current, pattern), efbc_list, ess_list, domain,
                          pattern, cnt0, cnt1, cnt2, cnt3)
        +
        (!contains(current, efbc_list) && domain == secure) ->
            memfault(current) .
            send_validation_request(current, domain) .
            receive_validation_result(current, valid) .
            EnclaveExecutor(current, add_block(current, efbc_list), ess_list, domain,
                          pattern, cnt0, cnt1, cnt2, cnt3)
        +
        (domain == attacker_privileged) ->
            attack_successful(current) .
            delta;

    ESSManager(ess_blocks: BlockList, val0: ValidationResult, val1: ValidationResult,
               val2: ValidationResult, val3: ValidationResult) =
        
        sum b: BlockID . 
            (list_size(ess_blocks) < 2) ->
                ess_load(b) .
                ESSManager(add_block(b, ess_blocks), val0, val1, val2, val3);

    ValidationEngine(validating: BlockID, domain: SecurityDomain) =
        
        sum b: BlockID, d: SecurityDomain . 
            (validating == invalid_block) ->
                receive_validation_request(b, d) .
                validate_start(b, d) .
                ValidationEngine(b, d)
        +
        (validating != invalid_block && domain == secure) ->
            validate_complete(validating, valid) .
            send_validation_result(validating, valid) .
            ValidationEngine(invalid_block, domain)
        +
        (validating != invalid_block && domain == attacker_privileged) ->
            validate_complete(validating, replayed) .
            send_validation_result(validating, replayed) .
            ValidationEngine(invalid_block, domain);

init
    allow({
        execute_instruction, memfault, ess_load, efbc_load,
        validate_start, validate_complete, dma_request, dma_progress, dma_complete,
        security_violation, attacker_monitor_dma, attacker_inject_command,
        attacker_read_obsolete_efb, attacker_attempt_replay, 
        dma_handover_start, dma_handover_complete, dma_race_condition_detected,
        attack_successful, host_os_compromised,
        sync_validation_request, sync_validation_result,
        sync_dma_attack_request, sync_attack_result, sync_handover_signal
    },
    comm({
        send_validation_request | receive_validation_request -> sync_validation_request,
        send_validation_result | receive_validation_result -> sync_validation_result,
        send_dma_attack_request | receive_dma_attack_request -> sync_dma_attack_request,
        send_attack_result | receive_attack_result -> sync_attack_result,
        send_handover_signal | receive_handover_signal -> sync_handover_signal
    },
        xTEESystemWithAttacker
    )
);